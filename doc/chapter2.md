## 第二章 Java虚拟机结构
该文档为一类抽象机器的规范，并没有描述任何Java虚拟机的特定实现。

想要正确实现Java虚拟机，你仅需要能够读取 *class* 文件格式并且正确地执行其规定操作即可。实现的细节并非Java虚拟机规范的一部分，这样不会毫无必要地限制实现者的创造力。例如，运行时数据区的内存层次、所用的垃圾回收算法以及Java虚拟机指令的任何内部优化都留给实现者决定。

本规范中所有关于Unicode的引用都参考自**The Unicode Standard, Version 6.0.0**。可从http://www.unicode.org/获取

### 2.1 *class* 文件格式
Java虚拟机可执行的编译代码为独立于硬件和操作系统的二进制格式，一般（但不是必须）以文件存储，即所谓的 *class* 文件格式。该文件格式精确地定义了类或接口的表现形式，包括字节顺序，这类在平台相关的对象文件中或许是理所当然要包括的细节。

第四章 *class* 文件格式 一节将详细介绍 *class* 文件格式

### 2.2 数据类型
像Java编程语言一样，Java虚拟机可以操作两种数据类型：原始类型和引用类型。相应地，有两类数值：原始数值和引用值可以用变量存储，作为参数传递，作为方法的返回值。

Java虚拟机预期几乎所有类型检查在运行时之前由编译器执行，而不必由Java虚拟机自身去完成。原始类型的值不应该被标记，除此之外，也不必可以预测以便在运行时决定它们的类型或者与引用类型的值区分。相反，Java虚拟机的指令集通过特定类型的值被执行的指令来区分运算对象的类型。例如，*iadd*, *ladd*, *fadd*, 和 *dadd* 都是Java虚拟机对两个数值进行加法操作并产生数值结果的指令，但是每一个都各自用于特定运算类型：int, long, float 和 double。Java虚拟机指令集所支持的类型汇总可见 2.11.1节。

Java虚拟机直接支持对象类型。一个对象要么是动态分配的类实例，要么是一个数组。对象的引用在Java虚拟机中为 reference 类型。reference[^1] 类型的值可以被认为是对象的指针。一个对象可以有多个引用。对象总是通过 reference 类型的值（译者注：即指针)进行运算、传递及检验。

[^1]:reference在原文中是Java虚拟机的一种类型，因此用英文，没有翻译为引用


### 2.3 原始数据类型和值
Java虚拟机支持的原始数据类型包括数值类型、布尔值类型(2.3.4)、和返回地址类型(2.3.3)。

数值类型由整型和浮点数构成。

整型包括：
* byte，值为8位有符号的2组整数，默认值为0
* short，值为16位有符号2组整数，默认值为0
* int，值为32位有符号2组整数，默认值为0
* long，值为64位有符号2组整数，默认值为0
* char，值为16为无符号整数，Basic Multilinggual Plane的 Unicode表示，以UTF-16编码，默认值为null的Unicode表示('\u0000')

浮点数包括：
* float，值为单精度数值集合元素或者基于单精度数的幂扩展集合，默认值为正的0
* double，值为双精度数值集合元素或者基于双精度的幂扩展集合，默认值为正0

boolean类型的值为true和false，默认值为false

第一版Java虚拟机规范没有将boolean作为Java虚拟机的类型，然而，Java虚拟机对boolean提供了有限支持。第二版Java虚拟机规范明确将boolean作为一种类型。

returnAddress类型的值是指向Java虚拟机指令操作码的指针。作为一种原始数据类型，returnAddress与Java编程语言没有直接的联系。

#### 2.3.1 整型及值
Java虚拟机整型的数值范围如下：
* byte，从-128到127（-2^7 到 2^7 - 1）， 闭区间；
* short，从-32768到32767（-2^15 到 2^15 - 1），闭区间；
* int，从-2147483648到2147483647（-2^31 到 2^32 - 1），闭区间；
* long，从-9223372036854775808到9223372036854775807（-2^63 到 2^63 - 1），闭区间；
* char，从0到65535，闭区间

#### 2.3.2 浮点数类型，值集合及值
浮点数包括 float 和 double，从概念上，各自对应32位单精度和64位双精度格式的IEEE 754标准，及IEEE Standard for Binary Floating-Point Arithmetric规定的操作。

IEEE 754 标准不仅包括正负有符号数，还包括正负零，正负无穷大和一个特殊的非数值（及NaN）。NaN代表一类非法操作的结果，例如0除以0。

略

#### 2.3.3 returnAddress类型和值
returnAddress用于Java虚拟机的 *jsr*，*ret* 和 *jsr_w* 指令。returnAddress的值为指向Java虚拟机指令操作码的指针。与原始数值类型不同，returnAddress不对应Java语言任何类型，并且不能在执行程序的时候修改。

#### 2.3.4 布尔值
尽管Java虚拟机定义了boolean类型，但仅提供了很有限的支持。并没有专用于boolean类型的指令。相反，Java语言对boolean值的操作编译为Java虚拟机int值。

Java虚拟机直接支持boolean数组。它的 *newarray* 指令能够创建boolean数组。boolean类型数组可以通过byte数组指令 *baload* 和 *bastore* 进行访问和修改。

在 Oracle的Java虚拟机实现中，Java编程语言的boolean数组被编码为Java虚拟机的byte数组，每个boolean值使用8个bit。

Java虚拟机编码boolean数组时，用1表示true，0表示false。Java编程语言的boolean值映射为Java虚拟机的int型，编译器必须使用相同的编码。

### 2.4 引用类型及值
reference类型有三种：class、array、和interface。他们的值为动态创建的类实例的引用，数组的引用或者实现了接口的类实例和数组的引用。

数组类型由一个一维的组件类型组成（该组件类型没有给定一维数组的长度）。数组类型的组件类型可能自身就是一个数组类型(译者注：嵌套的数组)。从任一数组类型起，考虑它的组件类型（如果该组件类型也是数组类型），然后考虑该组件类型的组件类型，如此下去，直到最终确定组件类型不是数组类型，那么最终的组件类型被称作数组类型的元素类型。一个数组类型的元素类型必然要么是原始类型，要么是类，要么是接口。

reference的值也可能是特殊的null引用，没有指向任何对象，以null表示。null引用一开始没有运行时类型，但是可以被强制转换为任意类型。reference的默认值为null。

此规范没有强制要求将null编码为一个具体的值。

### 2.5 运行时数据区
Java虚拟机在执行程序期间，定义了各类运行时数据区以供使用。其中一些数据区在Java虚拟机启动阶段创建，仅在Java虚拟机退出时销毁。其他数据区属于各个线程。线程的数据区在线程创建时创建，线程退出时销毁。

#### 2.5.1 pc计数器
Java虚拟机能够支持同时执行许多线程（JLS 17节）。每个Java虚拟机线程有自己的pc（程序计数器）。在任意时刻，每个Java虚拟机线程执行一个方法的代码。此方法被称作该线程的当前方法（current method，参考2.6节）。如果该方法不是native，那pc会包含正在执行的Java虚拟机指令地址。如果线程当前执行的方法是native，则Java虚拟机的pc的值是未定义。Java虚拟机pc足够大，以容纳一个returnAddress或者特定平台的native指针。

#### 2.5.2 栈
每个Java虚拟机线程都有一个私有的Java虚拟机栈，与线程同时创建。Java虚拟机栈存储帧（2.6节）。Java虚拟机栈与传统语言，比如C的栈有类似之处：保存局部变量，部分结果，在方法调用和返回的过程中发挥作用。因为Java虚拟机栈除了push和pop帧之外，不能直接操作，帧可能是堆分配的。Java虚拟机栈的内存不必是连续的。

> 在第一版Java虚拟机规范中，将Java虚拟机栈称为Java栈

此规范允许Java虚拟机栈根据计算需求可以为固定大小或者动态扩展和收缩。如果Java虚拟机栈是固定大小，该栈在创建时可以独立选择尺寸。

> 一类Java虚拟机实现可以让程序员或使用者控制栈的初始尺寸。如果栈是动态扩张或者收缩的情形，也可以让他们控制栈的最大和最小尺寸。

接下来是一些关于栈的异常情况：
* 如果线程计算时的请求超出栈所允许的大小，Java虚拟机会抛出StackOverflowError。
* 如果栈能动态扩展，尝试扩展时，内存不足以满足要求，或者内存不足以为新线程初始化栈，Java虚拟机会抛出OutOfMemoryError。

#### 2.5.3 堆
Java虚拟机堆为所有线程共享。堆是运行时数据区，所有类实例和数组都是在此分配内存。

堆在虚拟机启动时创建。对象的堆存储由自动存储管理系统回收（即所谓的垃圾收集器），对象绝不会显示释放（译者注：即不会由程序员释放）。Java虚拟机不会假定任何类型的自动存储管理系统，该管理系统所用技术由实现者根据系统需求选择。堆可以是固定尺寸，也可以根据计算需求扩展，如果更大的堆变得没有必要，也会进行收缩。堆使用的内存不必是连续的。

> Java虚拟机实现可以让程序员或者使用者控制堆的初始化尺寸。当堆时动态扩展和收缩时，也可以让他们控制堆的最大和最小尺寸。

接下来是堆的一些异常情况：
* 如果计算请求更多的堆，超过了自动存储管理系统所能给予的，Java虚拟机会抛出OutOfMemoryError。

#### 2.5.4 方法区
Java虚拟机方法区为所有线程共享。该方法区类似传统语言的编译代码存储区，或者类似操作系统进程的text段。该区存储每个类的结构，例如运行时常量池，属性，方法数据，方法和构造函数代码，其中包括类使用的特殊方法，以及实例初始化和接口初始化方法。

方法区在虚拟机启动时创建。尽管方法区逻辑上是堆的一部分，简单的虚拟机实现在该区域会选择不使用垃圾收集或者压缩。此规范并不强制要求方法区的位置或方法区管理编译代码的策略。方法区可以是固定大小，也可以根据计算需求进行扩展，或者当更大的方法区没有必要时进行收缩。方法区的内存不必连续。

> Java虚拟机实现可以让程序员或者使用者控制方法区的初始大小。当方法区尺寸可变时，也可以让他们控制方法区的最大和最小尺寸。

下面是方法区相关的异常条件：
* 如果方法区的内存不能满足一次分配请求，Java虚拟机会抛出OutOfMemoryError。

#### 2.5.5 运行时常量池
运行时常量池是每个类或每个接口在class文件的constant_pool表的运行时表示。包括数种常量，从编译时已知的数字字面量到运行时确定的方法和属性引用。运行时常量池功能类似传统编程语言的符号表，尽管它包含比典型的符号表范围更广的数据。

每个运行时常量池在Java虚拟机方法区分配。类或接口的运行时常量池在虚拟机创建类或接口时构造。

下面是类或接口的运行时常量池构造时的异常情形
* 当创建类或接口时，如果运行时常量池构造需要的内存超出方法区所能提供，则虚拟机抛出OutOfMemoryError。

> 参考第五章（载入，链接和初始化）关于运行时常量池的构造信息。

#### 2.5.6 原生方法栈
虚拟机实现可能用到传统的栈，即俗话所谓的C栈，以便支持native方法（即使用其他语言写的方法）。其他语言比如C，实现Java虚拟机指令集的解释器会用到原生方法栈。虚拟机实现如果不能载入native方法，他们本身也不依赖传统栈，则不必提供原生方法栈。如果提供了，那原生方法栈一般在每个线程创建时为每个线程分配。

此规范允许原生方法栈为固定尺寸或者根据计算需求动态扩展和收缩。如果原生方法栈为固定值，当栈创建时，该栈尺寸可以独立选择。

> Java虚拟机实现可以让程序员或使用者控制原生方法栈的初始尺寸，同时，对于尺寸变换的原生方法栈，他们可以控制其最大和最小尺寸。

下面是原生方法栈相关的异常情形：
* 如果线程计算需要更大的原生方法栈，但是超过系统允许的范围，虚拟机会抛出StackOverflowError。

* 如果原生方法栈可动态扩展，当扩展时，没有足够的内存；或者为新线程初始化原生方法栈时，内存不足，虚拟机会抛出OutOfMemoryError。

### 2.6 帧
帧一般用来存储数据及部分结果，也用来执行动态链接，返回方法的值，派发异常。

每次方法调用的时候创建新的帧。当方法调用完成时，帧被销毁，不论正常完成还是意外打断（抛出未捕获的异常)。线程创建帧，并在栈中为帧分配内存。每个帧有自己的局部变量，自己的操作栈（2.6.2节）以及当前方法所属类的运行时常量池的引用。

> 帧可以提供额外的特定虚拟机实现信息，例如调试信息。

局部变量数组和操作栈的尺寸在编译器决定，
